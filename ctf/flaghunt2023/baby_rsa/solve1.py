from decimal import Decimal, getcontext
import math
from Crypto.Util.number import getPrime, bytes_to_long as b2l, long_to_bytes as l2b

# Set the precision to a sufficiently large value
getcontext().prec = 200

# n1 = a*b
# n2 = b*c
# n3 = c*a

n = 115511598810808994122024459795381579432751132392069312326797280658177070183070520208497145368454904586561346235353033664171878557683129995458055761011836898338089634775745552096426217582906578756082099346204179943077536188707090978859976921126375222699628529040094844198971549729709421970935859728215539554063
p = 9587568566212807729996071563173511111774308425557022286992300383711822023894412475819216438637734128849431145962299782758065311243648137910038414792653887
q = 12048059736217074359195048019572678985298323492526394603624672718789017505016640661337406285953558084206253217378482812553146356120862233746830593072492849
c = 3525882571620506011987790479364462501137794014298431613259484650388212205397393977058860004603864269609190725322401786963636613761305984350408385598291975860084961232055016100421557466939324818761623425202829518013374242631303348175642183283272340836587262997239302692424441773662319241362854900290449239368
e = 65537

# phi = 115511598810808994122024459795381579432751132392069312326797280658177070183070520208497145368454904586561346235353033664171878557683129995458055761011836876702461332345863462905306634836716481683450181262787289326104433687867562067806839764503650631407415473355731503416376238518042057460564202859207674407328
# d = 106480342691264533956297415042165301406393245971010015191400340516081775805573024968429101776774435063978067505628619295262457837638447478761730361322735267592746028518404098211671112965051082715752564209969460153164581112732395855812969935959214574899922043911680536428178551010734010060958926825050173702945

# Calculate phi
# phi = (p - 1) * (q - 1)

# # Calculate modular inverse of e
# def egcd(a, b):
#     if a == 0:
#         return (b, 0, 1)
#     else:
#         g, y, x = egcd(b % a, a)
#         return (g, x - (b // a) * y, y)

# def modinv(e, phi):
#     g, x, y = egcd(e, phi)
#     if g != 1:
#         raise Exception('modular inverse does not exist')
#     else:
#         return x % phi

# d = modinv(e, phi)

# Decrypt ciphertext
n = 74878045830836179736126053427934924416142879576421383916734145506934646089995082153999364721093650523511577313451872564433526627468231463003512948378532388362965687980834477235117626062515123182939873022106153429916086233969684539378835695456225223944573997175916454125152681427031201471922315691435432518049




c = 48494528402611115875859676291604701336214955366916011666429083350239977140337617170820901971193365486601183732804851837773357719668925122450867360942382742315846018035095617847950680609654048313166542135770917443288444559326762980257475740778761652093999479653427882273902428898883602843856490885750961738320
d = 7197601741314351915462613466895976980093310625563907292983354386828171436043528972542997336780133736685656440242868152318588945530248485109522506562053910949945344633883179738816002259538139865443478192129709754900051371421525840200988655656409804253019401895683362324719975629521684605770711099317620969066389
m = pow(c, d, n)


# Convert the plaintext from int to string if necessary
# plaintext = str(m)
# print(plaintext)

flag_bytes = l2b(m)
print(flag_bytes)
plaintext = flag_bytes.decode("latin-1", errors="ignore")

print(plaintext)

# flag = flag_bytes.decode('ascii-8')
# print(flag)